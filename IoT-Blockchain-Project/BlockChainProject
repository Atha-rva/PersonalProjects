{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "6f93d62b-e9d3-49ed-ab87-6685089aca54",
   "metadata": {},
   "outputs": [],
   "source": [
    "import tkinter as tk\n",
    "from tkinter import ttk, messagebox\n",
    "import hashlib\n",
    "import datetime\n",
    "import json\n",
    "import random\n",
    "\n",
    "# Blockchain Classes\n",
    "class Block:\n",
    "    def __init__(self, index, timestamp, data, previous_hash):\n",
    "        self.index = index\n",
    "        self.timestamp = timestamp\n",
    "        self.data = data\n",
    "        self.previous_hash = previous_hash\n",
    "        self.hash = self.calculate_hash()\n",
    "\n",
    "    def calculate_hash(self):\n",
    "        to_hash = f\"{self.index}{self.timestamp}{self.data}{self.previous_hash}\"\n",
    "        return hashlib.sha256(to_hash.encode()).hexdigest()\n",
    "\n",
    "\n",
    "class Blockchain:\n",
    "    def __init__(self):\n",
    "        self.chain = [self.create_genesis_block()]\n",
    "\n",
    "    def create_genesis_block(self):\n",
    "        return Block(0, str(datetime.datetime.now()), \"Genesis Block\", \"0\")\n",
    "\n",
    "    def get_latest_block(self):\n",
    "        return self.chain[-1]\n",
    "\n",
    "    def add_block(self, data):\n",
    "        previous_block = self.get_latest_block()\n",
    "        new_block = Block(len(self.chain), str(datetime.datetime.now()), data, previous_block.hash)\n",
    "        self.chain.append(new_block)\n",
    "\n",
    "    def is_chain_valid(self):\n",
    "        for i in range(1, len(self.chain)):\n",
    "            current_block = self.chain[i]\n",
    "            previous_block = self.chain[i - 1]\n",
    "\n",
    "            if current_block.hash != current_block.calculate_hash():\n",
    "                return False, i\n",
    "            if current_block.previous_hash != previous_block.hash:\n",
    "                return False, i\n",
    "        return True, -1\n",
    "\n",
    "    def to_dict(self):\n",
    "        return [\n",
    "            {\n",
    "                \"index\": block.index,\n",
    "                \"timestamp\": block.timestamp,\n",
    "                \"data\": block.data,\n",
    "                \"previous_hash\": block.previous_hash,\n",
    "                \"hash\": block.hash,\n",
    "            }\n",
    "            for block in self.chain\n",
    "        ]\n",
    "\n",
    "    def from_dict(self, chain_data):\n",
    "        self.chain = []\n",
    "        for block_data in chain_data:\n",
    "            block = Block(\n",
    "                block_data[\"index\"],\n",
    "                block_data[\"timestamp\"],\n",
    "                block_data[\"data\"],\n",
    "                block_data[\"previous_hash\"],\n",
    "            )\n",
    "            block.hash = block_data[\"hash\"]\n",
    "            self.chain.append(block)\n",
    "\n",
    "\n",
    "# Tkinter Application\n",
    "def create_interactive_interface():\n",
    "    blockchain = Blockchain()\n",
    "\n",
    "    # Tkinter window setup\n",
    "    root = tk.Tk()\n",
    "    root.title(\"Enhanced IoT Blockchain Interface\")\n",
    "    root.geometry(\"900x700\")\n",
    "    root.configure(bg=\"#f0f0f0\")  # Light gray background\n",
    "\n",
    "    # Styling\n",
    "    style = ttk.Style()\n",
    "    style.configure(\"TLabel\", font=(\"Arial\", 12), background=\"#f0f0f0\")\n",
    "    style.configure(\"TButton\", font=(\"Arial\", 11), padding=6)\n",
    "    style.configure(\"TEntry\", padding=5)\n",
    "    style.configure(\"Treeview\", font=(\"Arial\", 10), rowheight=30)\n",
    "\n",
    "    # Functions\n",
    "    def add_data_to_blockchain():\n",
    "        temperature = temp_entry.get()\n",
    "        location = location_entry.get()\n",
    "\n",
    "        if temperature and location:\n",
    "            try:\n",
    "                float(temperature)\n",
    "                data = f\"Temperature: {temperature}, Location: {location}\"\n",
    "                blockchain.add_block(data)\n",
    "                update_blockchain_view()\n",
    "                temp_entry.delete(0, tk.END)\n",
    "                location_entry.delete(0, tk.END)\n",
    "                messagebox.showinfo(\"Success\", \"Data added to blockchain!\")\n",
    "            except ValueError:\n",
    "                messagebox.showerror(\"Invalid Input\", \"Temperature must be a number.\")\n",
    "        else:\n",
    "            messagebox.showerror(\"Missing Data\", \"Please fill in both fields.\")\n",
    "\n",
    "    def auto_simulate_data():\n",
    "        temperature = round(random.uniform(-10, 40), 2)\n",
    "        location = f\"Location-{random.randint(1, 100)}\"\n",
    "        data = f\"Temperature: {temperature}, Location: {location}\"\n",
    "        blockchain.add_block(data)\n",
    "        update_blockchain_view()\n",
    "        messagebox.showinfo(\"Auto-Simulate\", f\"Added simulated data: {data}\")\n",
    "\n",
    "    def update_blockchain_view():\n",
    "        tree.delete(*tree.get_children())\n",
    "        for block in blockchain.chain:\n",
    "            tree.insert(\"\", \"end\", values=(block.index, block.timestamp, block.data, block.hash[:10]))\n",
    "\n",
    "    def validate_blockchain():\n",
    "        is_valid, invalid_index = blockchain.is_chain_valid()\n",
    "        if is_valid:\n",
    "            messagebox.showinfo(\"Blockchain Validation\", \"The blockchain is valid!\")\n",
    "        else:\n",
    "            messagebox.showerror(\"Blockchain Validation\", f\"Blockchain is invalid at block {invalid_index}.\")\n",
    "\n",
    "    def save_blockchain():\n",
    "        with open(\"blockchain_data.json\", \"w\") as file:\n",
    "            json.dump(blockchain.to_dict(), file, indent=4)\n",
    "        messagebox.showinfo(\"Save Blockchain\", \"Blockchain data saved to blockchain_data.json\")\n",
    "\n",
    "    def load_blockchain():\n",
    "        try:\n",
    "            with open(\"blockchain_data.json\", \"r\") as file:\n",
    "                chain_data = json.load(file)\n",
    "                blockchain.from_dict(chain_data)\n",
    "                update_blockchain_view()\n",
    "                messagebox.showinfo(\"Load Blockchain\", \"Blockchain data loaded successfully!\")\n",
    "        except FileNotFoundError:\n",
    "            messagebox.showerror(\"Load Blockchain\", \"No blockchain data file found.\")\n",
    "\n",
    "    def search_blockchain():\n",
    "        query = search_entry.get()\n",
    "        results = []\n",
    "        for block in blockchain.chain:\n",
    "            if query in block.data:\n",
    "                results.append(block)\n",
    "\n",
    "        if results:\n",
    "            result_text = \"\\n\".join([f\"Block {block.index}: {block.data}\" for block in results])\n",
    "            messagebox.showinfo(\"Search Results\", f\"Found matches:\\n{result_text}\")\n",
    "        else:\n",
    "            messagebox.showinfo(\"Search Results\", \"No matches found.\")\n",
    "\n",
    "    # Input Frame\n",
    "    input_frame = ttk.LabelFrame(root, text=\"Input IoT Data\", padding=10)\n",
    "    input_frame.pack(fill=\"x\", padx=10, pady=10)\n",
    "\n",
    "    ttk.Label(input_frame, text=\"Temperature:\").grid(row=0, column=0, padx=5, pady=5)\n",
    "    temp_entry = ttk.Entry(input_frame, font=(\"Arial\", 11))\n",
    "    temp_entry.grid(row=0, column=1, padx=5, pady=5)\n",
    "\n",
    "    ttk.Label(input_frame, text=\"Location:\").grid(row=1, column=0, padx=5, pady=5)\n",
    "    location_entry = ttk.Entry(input_frame, font=(\"Arial\", 11))\n",
    "    location_entry.grid(row=1, column=1, padx=5, pady=5)\n",
    "\n",
    "    add_button = ttk.Button(input_frame, text=\"Add to Blockchain\", command=add_data_to_blockchain)\n",
    "    add_button.grid(row=2, column=0, pady=10)\n",
    "\n",
    "    auto_button = ttk.Button(input_frame, text=\"Auto-Simulate Data\", command=auto_simulate_data)\n",
    "    auto_button.grid(row=2, column=1, pady=10)\n",
    "\n",
    "    # Blockchain Display\n",
    "    table_frame = ttk.LabelFrame(root, text=\"Blockchain Data\", padding=10)\n",
    "    table_frame.pack(fill=\"both\", expand=True, padx=10, pady=10)\n",
    "\n",
    "    columns = (\"Index\", \"Timestamp\", \"Data\", \"Hash\")\n",
    "    tree = ttk.Treeview(table_frame, columns=columns, show=\"headings\", height=15)\n",
    "    for col in columns:\n",
    "        tree.heading(col, text=col)\n",
    "        tree.column(col, anchor=\"center\", width=150 if col == \"Data\" else 100)\n",
    "    tree.pack(fill=\"both\", expand=True)\n",
    "\n",
    "    # Search and File Operations\n",
    "    control_frame = ttk.Frame(root, padding=10)\n",
    "    control_frame.pack(fill=\"x\", padx=10, pady=5)\n",
    "\n",
    "    ttk.Label(control_frame, text=\"Search:\").grid(row=0, column=0, padx=5, pady=5)\n",
    "    search_entry = ttk.Entry(control_frame)\n",
    "    search_entry.grid(row=0, column=1, padx=5, pady=5)\n",
    "\n",
    "    search_button = ttk.Button(control_frame, text=\"Search Blockchain\", command=search_blockchain)\n",
    "    search_button.grid(row=0, column=2, padx=5, pady=5)\n",
    "\n",
    "    validate_button = ttk.Button(control_frame, text=\"Validate Blockchain\", command=validate_blockchain)\n",
    "    validate_button.grid(row=0, column=3, padx=5, pady=5)\n",
    "\n",
    "    save_button = ttk.Button(control_frame, text=\"Save Blockchain\", command=save_blockchain)\n",
    "    save_button.grid(row=0, column=4, padx=5, pady=5)\n",
    "\n",
    "    load_button = ttk.Button(control_frame, text=\"Load Blockchain\", command=load_blockchain)\n",
    "    load_button.grid(row=0, column=5, padx=5, pady=5)\n",
    "\n",
    "    update_blockchain_view()\n",
    "    root.mainloop()\n",
    "\n",
    "\n",
    "# Run the application\n",
    "create_interactive_interface()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2e9f2714-7f28-4872-8652-40e9f9ac3286",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
